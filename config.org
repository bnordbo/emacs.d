* Basic initialisation
** Load extra files

Load various add-on functionality.

#+begin_src emacs-lisp
(load-file "~/.emacs.d/elisp/bn.el")
(load-file "~/.emacs.d/elisp/org-tags.el")
#+end_src

** Configure package installation

Automatically ensure packages are installed if they are not already there.

#+begin_src emacs-lisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

Ensure packages are always compiled, and that the latest version available is
used.

#+begin_src emacs-lisp
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+end_src

** General defaults

Who wouldn't want sensible defaults?

#+begin_src emacs-lisp
(load-file "~/.emacs.d/sensible-defaults.el")
(sensible-defaults/use-all-settings)
#+end_src

** Servers

Start emacs-server for integrating neatly with the shell.

#+begin_src emacs-lisp
(use-package server)
(if (not (server-running-p))
  (server-start))
#+end_src

* Experiments

This section is for testing out new configurations.

#+begin_src emacs-lisp
(global-hl-line-mode 1)
;(setq org-src-fontify-natively t)
(setq org-src-window-setup 'current-window)
;(setq org-adapt-indentation nil)
; "Breaks" if projectile is not loaded
;(setq frame-title-format '((:eval (projectile-project-name))))
#+end_src


* Look and feel

** SOMEDAY Look into [[https://github.com/kunalb/poet][poet theme]]                                       :emacs:

While I find dark themes more aesthetically pleasing, bright ones are more
ergonomic.

#+begin_src emacs-lisp
(use-package leuven-theme)
#+end_src

Conserve space and reduce clutter.

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(when (window-system)
  (scroll-bar-mode -1))
#+end_src

I don't think I've ever had any use of seeing the minor modes in the mode line.
This saves a lot of space that I can surely find some other use for.

#+begin_src emacs-lisp
(use-package minions
  :config
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  (minions-mode 1))
#+end_src

Run in full screen mode. On Mac this no longer creates a new desktop, but rather
an undecorated, maximised frame. It's a bit funky, but I have not had time to
look into it yet.

#+begin_src emacs-lisp
(toggle-frame-fullscreen)
#+end_src

I find transparency neat for about ten minutes...

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha . (100 . 100)))
#+end_src

Incosolata LGC Markup as it has more glyphs (like em dash) than InconsolataGo.
Libre Baskerville is as nice as Baskerville, and easier to read on the screen.

#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Libre Baskerville" :height 130))))
 '(fixed-pitch ((t (:family "Inconsolata LGC Markup" :height 130)))))
#+end_src

Why not?

#+begin_src emacs-lisp
(global-prettify-symbols-mode t)
#+end_src

Define modes and related hooks used for writing prose.

#+begin_src emacs-lisp
(defvar prose-modes '(text-mode git-commit-mode markdown-mode))
(defvar prose-mode-hooks
  (mapcar (lambda (n) (intern (format "%s-hook" n)))
          prose-modes))
#+end_src

Set up prose modes with a variable pitch font. I'm still not sure about this,
but variable pitch fonts /are/ easier to read.

#+begin_src emacs-lisp
(dolist (h prose-mode-hooks)
  (add-hook h (lambda () (variable-pitch-mode 1))))
#+end_src

Prevent horizontal splits for big windows.

#+begin_src emacs-lisp
(setq split-height-threshold nil)
#+end_src

Zoom mode allows me to continue using a three-way split when I disconnect the
monitor. It mostly works great.

#+begin_src emacs-lisp
(zoom-mode 1)
(setq zoom-size '(100 .  40))
#+end_src

No ugly line wrapping.

#+begin_src emacs-lisp
(set-default 'truncate-lines t)
#+end_src

I've never missed the bell, visible or otherwise.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

Auto-highlighting the current symbol can be quite useful, not only when
programming.

#+begin_src emacs-lisp
(setq ahs-idle-interval 1.0
      ahs-default-range 'ahs-range-whole-buffer
      ahs-inhibit-face-list '(font-lock-comment-delimiter-face
                              font-lock-comment-face
                              font-lock-doc-face
                              font-lock-doc-string-face
                              font-lock-string-face))
#+end_src

* General editing setup

As a rule, I don't want to indent with tabs. Spaces are more predicable, and I
anyway leave it to Emacs most of the time.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

This eliminates all the tilde suffixed files. I've got TimeMachine for backups.

#+begin_src emacs-lisp
(setq backup-inhibited t)
#+end_src

Unconditionally auto-save all visited files every time Emacs loses focus.

#+begin_src emacs-lisp
(add-hook 'focus-out-hook
          (lambda ()
            (interactive)
            (save-some-buffers t)))
#+end_src

Automatically saving files is useful, but this had some side effects I can't
quite recall. Experiment more.

#+begin_src emacs-lisp
;(auto-save-visited-mode t)
;(setq auto-save-visited-interval 45)
#+end_src

Some like having the lines numbered, but I find just showing it in the modeline
will usually suffice.

#+begin_src emacs-lisp
(column-number-mode t)
#+end_src

Improve parenthesis handling by highlighting matching ones.

#+begin_src emacs-lisp
(show-paren-mode t)
#+end_src

Try to keep the whitespace under control. The whitespace butler seems to work
pretty well.

#+begin_src emacs-lisp
;(add-hook 'find-file-hook #'ws-butler-global-mode)
(ws-butler-global-mode 1)
(setq require-final-newline t)
#+end_src

Make regular expession alignment always use spaces and not tabs.

#+begin_src emacs-lisp
(defadvice align-regexp (around align-regexp-with-spaces activate)
  (let ((indent-tabs-mode nil))
    ad-do-it))
#+end_src

Getting the environment set correctly is/was a struggle on macOS. I've been
using this for a while, and it seems to work.

#+begin_src emacs-lisp
(exec-path-from-shell-initialize)
#+end_src

I just use ispell for now, but should look into a way of supporting multiple
dictionaries.

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/ispell")
#+end_src

* Integrations

I often switch from Emacs to searh  for stuff.  Let's put an end to that!

#+begin_src emacs-lisp
(use-package ripgrep)
#+end_src

Use projectile. This is quite neat in normal projects, but it's struggling in
big monorepos. Hmm.

#+begin_src emacs-lisp
(use-package projectile
  :bind (("C-c p" . projectile-command-map)))
#+end_src

It seems I'm practically living inside Emacs these days, so I might as well use
it as an entry-point for various web searches.

#+begin_src emacs-lisp
(use-package engine-mode)
(engine-mode 1)

(defengine qwant
  "https://www.qwant.com/?q=%s"
  :keybinding "q")

(defengine github-loltel-issue-lookup
  "https://github.com/omnicate/loltel/issues/%s"
  :keybinding "i")

(defengine github-loltel-issue-search
  "https://github.com/omnicate/loltel/issues?q=is%%3Aissue+is%%3Aopen+%s"
  :keybinding "s")
#+end_src

Elfeed seems to be the best choice for RSS feeds today, and also supports
defining the feeds in org! I could probably point it to the roam directory and
have it pick up all the feeds based on tags, but that seems a bit extreme...

Getting warning:

In end of data:
elfeed-org.el:385:1:Warning: the following functions are not known to be
    defined: org-element-map, org-element-parse-buffer, org-element-property,
    org-element-put-property

#+begin_src emacs-lisp
(use-package elfeed-org
  :init
  (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
  :config
  (elfeed-org))
#+end_src

* Programming language support

** Go

This sets up Go mode with some basic support.  The jump to definition
support is extremely limited, unfortunately.

#+begin_src emacs-lisp
(use-package go-mode
  :bind (("M-." . godef-jump))
  :hook (before-save . gofmt-before-save)
  :init
  (exec-path-from-shell-copy-env "GOPATH")
  (setq go-eldoc-gocode "/Users/bn/go/bin/gocode")
  :config
  (setq tab-width 4)
  (auto-highlight-symbol-mode 1)
  (electric-pair-mode 1)
  (electric-indent-mode 1)
  (subword-mode 1)
  (yas-minor-mode 1))

(use-package go-eldoc
  :config
  (go-eldoc-setup))

(use-package go-add-tags)
(use-package go-fill-struct)
(use-package go-playground)
#+end_src

** Elisp

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook emacs-lisp-mode-hook)

(use-package eldoc
  :hook emacs-lisp-mode-hook
  :config
  (eldoc-add-command
     'paredit-backward-delete
     'paredit-close-round))

(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)))
#+end_src

** Shell

#+begin_src emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (setq sh-basic-offset 2
                  sh-indentation 2)))
#+end_src

** Graphviz

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :init (setq graphviz-dot-view-command "xdot %s"))
#+end_src

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode)

(add-hook 'haskell-mode-hook
          (lambda ()
            (subword-mode 1)
            (electric-pair-local-mode 1)
            (haskell-doc-mode 1)))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode)

(setq racer-cmd "~/bin/racer"
      racer-rust-src-path "~/src/thirdparty/rust/src"
      company-tooltip-align-annotations t)

(add-hook 'rust-mode-hook
          (lambda ()
            (cargo-minor-mode 1)
            (electric-pair-local-mode 1)
            (racer-mode 1)))

(add-hook 'racer-mode-hook
          (lambda ()
            (eldoc-mode 1)
            (company-mode 1)))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :config
  (setq markdown-open-command "~/bin/mark")
  (set-face-attribute 'markdown-table-face nil :inherit 'fixed-pitch)
  (add-hook 'markdown-mode (lambda () (visual-line-mode 1))))
#+end_src

** Yaml

#+begin_src emacs-lisp
(use-package yaml-mode
  :config
  (add-hook 'yaml-mode-hook
            (lambda ()
              (variable-pitch-mode -1)
              (electric-indent-mode 1))))
#+end_src

** Bazel

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("BUILD\\'" . bazel-mode))
#+end_src

* Helm

#+begin_src emacs-lisp
(use-package helm
  :bind (("C-h" . nil)
         ("M-x" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-x M-b" . helm-recentf)
         ("C-x r b" . helm-filtered-bookmarks)
         ("C-x C-f" . helm-find-files)
         ("C-x 4 f" . find-file-other-window)
         ("C-c C-w" . org-refile)))
; I really don't get why this is needed. If it's not there, some targets, such
; as org-refile, does not seem to cause helm to be loaded/used.
(helm-mode 1)
#+end_src

#+begin_src emacs-lisp
(use-package helm-descbinds
  :after helm
  :config
  (helm-descbinds-mode 1))
#+end_src

Using Helm for projectile is great, but for some reason it barfs if I do not
bind "C-c" first.

#+begin_src emacs-lisp
(define-key global-map (kbd "C-c") (make-sparse-keymap))
(use-package helm-projectile
  :bind ("C-c p h" . helm-projectile))
#+end_src

* Key bindings

On Mac, map the command key to meta and keep the normal behaviour of
option.

#+begin_src emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier nil)
#+end_src

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode 1)
#+end_src

I picked up C-TAB switcing from Eclipse way back.  The reverse one is
perhaps overdoing it since I usually have no more than three buffers.

#+begin_src emacs-lisp
(global-set-key (kbd "C-<tab>")   'other-window)
(global-set-key (kbd "C-S-<tab>") 'other-window-back)
(global-set-key (kbd "C-c m") 'bn/next-line-and-indent)
#+end_src

Bind a few useful functions.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x \\")	    'align-regexp)
(global-set-key (kbd "C-x C-<SPC>") 'just-one-space)
#+end_src

Some stuff I missed after making an attempt at TextMate a while back.

#+begin_src emacs-lisp
(global-move-dup-mode t)
(global-set-key (kbd "C-x C-d") 'md-duplicate-down)
(global-unset-key (kbd "C-M-<up>"))
(global-unset-key (kbd "C-M-<down>"))
#+end_src

This allows quickly jumping to words in a buffer.  Awsum!

#+begin_src emacs-lisp
(global-set-key (kbd "C-M-j") 'ace-jump-mode)
#+end_src

I still consider this a bit of an experiment...

#+begin_src emacs-lisp
(global-set-key (kbd "C-?") 'help-command)
; Find another key for this.
;(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "C-h") 'delete-backward-char)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

The ability  to move to the next/prev occurence of the current symbol
is something I missed after using IntelliJ for a while.

#+begin_src emacs-lisp
(load-library "auto-highlight-symbol")
(define-key auto-highlight-symbol-mode-map (kbd "M-p") 'ahs-backward)
(define-key auto-highlight-symbol-mode-map (kbd "M-n") 'ahs-forward)
#+end_src

Interactive regular expressions because I find it tricky to remember
the Emacs syntax for these.

#+begin_src emacs-lisp
(define-key global-map (kbd "C-c r") 'vr/replace)
(define-key global-map (kbd "C-c q") 'vr/query-replace)
#+end_src

I tend to think snippets are kind of silly (why would you keep typing
the same thing?), but with Go it becomes useful...

#+begin_src emacs-lisp
(global-set-key (kbd "C-c y") 'helm-yas-complete)
#+end_src

* Org mode

Load the almighty org-mode and do basic configuration:

- Set up global keybindings.
- Clear some local keybindings that gets in the way.
- Also switch on auto-fill-mode in order to make prose easier to write.
- Ensure tables and blocks are still in monospace.

#+begin_src emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :bind (("C-c a" . org-agenda)
         ("C-c l" . org-store-link)
         ("C-c c" . org-capture)
         ("C-c C-x C-j" . org-clock-goto)
         :map org-mode-map
         ("C-<tab>" . nil)
         ("M-h" . nil))
  :config
  (setq org-edit-src-content-indentation 0)
  (set-face-attribute 'org-block  nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (add-hook 'org-mode-hook #'auto-fill-mode 1)
  (add-hook 'org-mode-hook #'electric-indent-mode -1))
#+end_src

Set  up fast selection for tags. Lots of them! Lowercase characters are for
categories, uppercase for contexts, including people. I could perhaps switch to
digits for contexts if clashes become a problem..

#+begin_src emacs-lisp
(setq org-tag-alist '(("admin" . ?a)
                      ("emacs" . ?e)
                      ("integrators" . ?i)
                      ("mdg" . ?m)
                      ("org" . ?o)
                      ("read" . ?r)
                      (:newline)
                      ("@home" . ?H)
                      ("@office" . ?O)
                      ("@standup" . ?S)
                      ("@tlf" . ?T)))
#+end_src

Maybe everything should always auto-save all the time..?

#+begin_src emacs-lisp
;(add-hook 'auto-save-hook 'org-save-all-org-buffers)
#+end_src

** Some basic settings.

I use org-mode in three ways: For GTD task management, for roam style
notes, and for very project specific notes.  The latter is scattered
in various contexts, while GTD and roam has their own directories, the
former being the default org directory.

#+begin_src emacs-lisp
(setq org-directory "~/Repository"
      org-default-notes-file "~/Repository/Inbox.org"
      org-agenda-restore-windows-after-quit t
      org-agenda-window-setup 'current-window
      org-log-done t)

(setq org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "WAITING(w@)"
                                    "PROJ(p)" "INACTIVE(i)" "SOMEDAY(s)"
                                    "|" "DONE(d)" "CANCELLED(c)")))
#+end_src

Emacs Lisp is a popular source language, so give it  its own key. As both "e"
and "E" are taken, it will have to live under "m".

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("m" . "src emacs-lisp"))
#+end_src

Exporting to Slack allows me to edit the message in e.g. an org-mode note.

#+begin_src emacs-lisp
(use-package ox-slack)
#+end_src

** Pomodoro

#+begin_src emacs-lisp
(use-package org-pomodoro)
#+end_src

** Contacts

It's easy to just stuff contacts into some random address book (GMail, your
phone, ...), but let's take a step back: Contacts are /people/ that you deal
with. Many of them you will deal with for years or decades. They should not just
be thrown into an address book as an afterthought.

#+begin_src emacs-lisp
(use-package org-contacts
   :ensure nil
   :after org
   :custom (org-contacts-files '("~/Repository/People/Contacts.org")))
#+end_src

** Agenda setup

#+begin_src emacs-lisp
(setq org-agenda-files
      '("~/Repository/GTD"
        "~/Repository/Roam"
        "~/Contexts/WG2/Meetings.org"
        "~/.emacs.d/config.org"))

(setq org-agenda-custom-commands
      '(("i" "Inbox"
         ((todo "TODO"
                ((org-agenda-files (list "~/Repository/Inbox.org"))))))
        ("n" "Next actions" todo "NEXT")
        ("p" "Projects" todo "PROJ")
        ("r" "Review"
         ((agenda)
          (stuck "")
          (tags-todo "@office")
          (tags-todo "@reading")
          (tags-todo "@home")
          (tags-todo "@project")))
        ("D" "Daily action list"
         ((agenda "" ((org-agenda-ndays 1)
                      (org-agenda-sorting-strategy
                       (quote ((agenda time-up priority-down tag-up) )))
                      (org-deadline-warning-days 0)))))))
#+end_src

** Capture and refile

Capture templates. NEXT is used for tasks I can start working on right away,
while TODO are effectively blocked. PROJ is for longer lived tasks with
sub-tasks. These are treated separately in weekly and daily reviews. MEETING is
used to record meetings, but I don't use it very often, so it's a candidate for
removal.

I use Diary to make a quick summary of the day, or when I have completed
significant tasks. Contacts is for recording new contacts, but it's mostly
experimental. Then there are templates for recurring meetings/standups that I
use for recording the outcome of these, and for tracking the time spent.

#+begin_src emacs-lisp
(setq org-capture-templates
      `(("n" "NEXT" entry (file+headline org-default-notes-file "Tasks")
         "* NEXT %i%?")
        ("t" "TODO" entry (file+headline org-default-notes-file "Tasks")
         "* TODO %i%?")
        ("p" "PROJ" entry (file+headline org-default-notes-file "Tasks")
         "* PROJ %i%?")
        ("m" "Meeting" entry (file+datetree "~/Contexts/WG2/Meetings.org")
         "* NEXT %? :meeting:\n%U" :clock-in t :clock-resume t)
        ("d" "Diary" entry (file+datetree "~/Repository/Timeline/Diary.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("c" "Contacts" entry (file ,(car (org-contacts-files)))
         "* %(org-contacts-template-name)
          :PROPERTIES:
          :EMAIL: %(org-contacts-template-email)
          :PHONE: %^{47 00000000}
          :END:")
        ("s" "Standup" item
         (file+datetree "~/Repository/Roam/20201007152101-integrators_standups.org")
         "%?\n" :clock-in t :clock-resume t)
        ("l" "Tech lead sync" item
         (file+datetree "~/Repository/Roam/20201007100233-tech_lead_sync.org")
         "%?\n" :clock-in t :clock-resume t)))
#+end_src

I usually refile from my inbox. Previously ~gtd~ was practically the only
target, but lately I've started refiling into ~config.org~ too. The way I've
used ~gtd~ is basically just as a task list, but with agenda mode I get more
flexibility. Maybe I could refile into the roam folder? That might eventually
spin out of control, but I could build a list of targets based on some criteria.

#+begin_src emacs-lisp
(setq org-refile-targets `(("~/.emacs.d/config.org" :level . 2)
                           (bn/roam-files :level . 1)))
#+end_src

** Roam

 Let's try to use the new Repository structure for org-roam. An alternative
 would have been to store it as a Context, but it's probably more of a cross
 context thing.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Repository/Roam")
#+end_src

 Start org

#+begin_src emacs-lisp
(use-package org-roam
    :ensure t
    :bind (("C-c n f" . org-roam-find-file)
           :map org-roam-mode-map
           (("C-c n l" . org-roam)
            ("C-c n g" . org-roam-graph)
            ("C-c n t a" . org-roam-tag-add)
            ("C-c n t d" . org-roam-tag-delete))
           :map org-mode-map
           (("C-c n i" . org-roam-insert)
            ("C-c n I" . org-roam-insert-immediate)))
    :hook (after-init . org-roam-mode)
    :init (make-directory org-roam-directory t)
    :config (setq org-roam-completion-system 'helm))
 #+end_src

 Also set up org-journal with org-roam for fleeting notes, i.e. notes
 that are not connected to a particular project.

#+begin_src emacs-lisp
(use-package org-journal
  :bind
  ("C-c n j" . org-journal-new-entry)
  :init
  (setq org-journal-file-type 'weekly
        org-journal-dir org-roam-directory
        org-journal-date-prefix "* "
        org-journal-file-header "#+title: %Y journal, week %V\n"
        org-journal-file-format "%Y-%V.org"
        org-journal-date-format "%A, %d %B %Y"
        org-journal-carryover-items ""))
 #+end_src

*** NEXT Make the roam links appear in existing buffer                :emacs:
    - Note taken on [2020-10-17 Sat 10:36] \\
      Right now it always opens a new buffer to the right, but most often I have a
      perfectly good buffer that that it could use.
*** DONE Make journal record weeks instead of days                      :org:
    CLOSED: [2020-10-19 Mon 09:34]
    :LOGBOOK:
    CLOCK: [2020-10-19 Mon 09:16]--[2020-10-19 Mon 09:34] =>  0:18
    :END:
** INACTIVE Filter for displaying agenda buffers                      :emacs:
   - Note taken on [2020-10-17 Sat 18:28] \\
     [[file:../Repository/Roam/20201017180724-boris_buliga.org][Boris Buliga]] has a nice solution for this in [[file:../Repository/Roam/20200928231429-task_management_with_org_roam.org][vol. 2 of his org-roam series]]. But I'm quite
     happy with the categories so far.
   - Note taken on [2020-10-14 Wed 20:53] \\
     Seems there may not be a hook for this, so it could be harder than I though. But
     FWIW [[file:elpa/org-plus-contrib-20201012/org-agenda.el::(defun org-agenda-format-item (extra txt &optional level category tags dotime][this is the function]] displaying each entry.
   :LOGBOOK:
   CLOCK: [2020-10-14 Wed 19:22]--[2020-10-14 Wed 20:54] =>  1:32
   :END:
   - Note taken on [2020-10-12 Mon 10:17] \\
     This is a [[https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][pretty good tutorial]] it seems.
   - Note taken on [2020-10-10 Sat 10:32] \\
     The roam file names are way too long because of the timestamp. Perhaps filter
     that out and replace it with e.g. ~R:~ or ~#~ or something..? Also make the file
     name display a bit wider as the roam files are still quite long.
** SOMEDAY Map C-c C-c to the same as RET in fast tag selection       :emacs:
** SOMEDAY Associate reMarkable notes with org-roam                   :emacs:
** SOMEDAY Find projects that are stuck                               :emacs:
   - Note taken on [2020-10-12 Mon 09:55] \\
     This would be ~PROJ~ tasks with no sub-tasks with the  ~NEXT~ state.
* Version control

Bind magit to ~C-x g~, and unbind ~C-<tab>~ since it's used for switching
buffers.

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-x g" . magit)
         :map magit-mode-map
         ("C-<tab>" . nil)))
#+end_src

* Tasks
** NEXT Test [[https://github.com/joaotavora/eglot][eglot]] for Go programing                                  :emacs:
** SOMEDAY Look into [[https://github.com/bbatsov/projectile][projectile]]                                       :emacs:
** NEXT Test the GitHub integration                                   :emacs:
   - Note taken on [2020-10-12 Mon 10:16] \\
     To use forge, I need to [[https://magit.vc/manual/ghub/Storing-a-Token.html#Storing-a-Token][set up a GitHub token]] in ~.netrc~ or similar.
   - Note taken on [2020-10-02 Fri 17:22] \\
     #+begin_src emacs-lisp
     (use-package ghub)
     (use-package forge
       :after magit)
     #+end_src
** SOMEDAY Test out [[https://github.com/manateelazycat/aweshell][aweshell]]                                          :emacs:
** SOMEDAY Look into dailies as a replacement for org-journal         :emacs:
   - Note taken on [2020-09-27 Sun 20:53] \\
     I guess the main thing I don't like about org-journal is that it
     doesn't capture journal entries – at least I haven't found a way yet.
     Also it seems to be everything and the kitchen sink.
** CANCELLED Make a template for backlog issues           :integrators:emacs:
   CLOSED: [2020-10-14 Wed 19:15]
   - Note taken on [2020-10-12 Mon 12:15] \\
     What did I mean with this?
