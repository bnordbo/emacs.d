* Basic initialisation
** Performance

Time the startup.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src

** Load extra files

Load various add-on functionality.

#+begin_src emacs-lisp
(load-file "~/.emacs.d/elisp/bn.el")
(load-file "~/.emacs.d/keyboard-macros.el")
#+end_src

** Configure package installation

Automatically ensure packages are installed if they are not already there.

#+begin_src emacs-lisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

Ensure packages are always compiled, and that the latest version available is
used.

#+begin_src emacs-lisp
(use-package auto-compile
  :init (setq load-prefer-newer t)
  :config (auto-compile-on-load-mode))
#+end_src

** General setup

Prevent customize from polluting the init files.

#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+end_src

Who wouldn't want sensible defaults?

#+begin_src emacs-lisp
(load-file "~/.emacs.d/elisp/sensible-defaults.el")
(sensible-defaults/use-all-settings)
#+end_src

Set location and time format for sunrise/sunset.

#+begin_src emacs-lisp
(setq calendar-latitude 59.41
      calendar-longitude 9.03
      calendar-time-display-form
      '(24-hours ":" minutes
                 (if time-zone " (") time-zone (if time-zone ")")))
#+end_src

After switcing to native compilation, the warning buffer started to pop up a
lot. Increasing the log level to ~error~ takes care of that annoyance.

#+begin_src emacs-lisp
(setq warning-minimum-level :error)
#+end_src

** Servers

Start emacs-server for integrating neatly with the shell.

#+begin_src emacs-lisp
(use-package server
  :config
  (unless (server-running-p)
    (server-start)))
#+end_src

* Experiments

** Various
This section is for testing out new configurations.

#+begin_src emacs-lisp
(defun bn/build-chordlet ()
  (interactive)
  (bazel-test "//voice/chordlet/..."))
(global-set-key (kbd "C-c v c") 'bn/build-chordlet)

; This seems like something I ought to look into to make org-note buffers behave.
; https://depp.brause.cc/shackle/
;(use-package shackle

(use-package writegood-mode
  :config
  (add-to-list 'writegood-weasel-words "actionable"))

(use-package free-keys)
(use-package boon
  :disabled
  :config
  (require 'boon-colemak))
(use-package 0xc
  :defer 15)
(use-package kubel
   :defer 15)

(use-package key-quiz)
#+end_src

** LSP mode

LSP is awesome, but unfortunately difficult to get working with Bazel. This is
mostly for playing around to maybe get that working at some point.

#+begin_src emacs-lisp
(use-package yasnippet)
(use-package company-box)

; hook up later
(defun lsp-go-install-save-hooks ()
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))

;; (use-package lsp-mode
;;   :init
;;   (setq lsp-keymap-prefix "C-c v")
;;   :hook ((kotlin-mode . lsp-deferred)
;;          (go-mode . lsp-deferred)
;;          (lsp-mode . lsp-enable-which-key-integration))
;;   :commands lsp lsp-deferred
;;   :config
;;   (add-to-list 'lsp-file-watch-ignored-directories "/bazel-.*\\'")
;;   (add-to-list 'lsp-file-watch-ignored-directories "/infra\\'")
;;   (add-to-list 'lsp-file-watch-ignored-directories "/docs.wgtwo.com\\'")
;;   (add-to-list 'lsp-file-watch-ignored-directories "/post-mortems\\'")
;;   (add-to-list 'lsp-file-watch-ignored-directories "/design-docs\\'")
;;   (lsp-register-custom-settings
;;    '(("gopls.completeUnimported" t t)
;;      ("gopls.staticcheck" t t)
;;      ("gopls.directoryFilters" ("-bazel-bin" "-bazel-out" "-bazel-testlogs" "-bazel-loltel"))
;;      ("gopls.allowImplicitNetworkAccess" t t)
;;      ("gopls.usePlaceholders" t t))))

(use-package kotlin-mode)

;; (use-package helm-lsp
;;   :after lsp-mode
;;   :commands helm-lsp-workspace-symbol
;;   :init (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol))

(use-package ob-kotlin)
#+end_src


** Go Eglot

#+begin_src emacs-lisp
;; (setenv "GOPACKAGESDRIVER" (expand-file-name "~/bin/gopackagesdriver.sh"))

;; (use-package eglot)
;; (use-package consult-eglot)

;; (defun project-find-go-module (dir)
;;   (when-let ((root (locate-dominating-file dir "go.mod")))
;;     (cons 'go-module root)))

;; (cl-defmethod project-root ((project (head go-module)))
;;   (cdr project))

;; (add-hook 'project-find-functions #'project-find-go-module)
;; (add-hook 'go-mode-hook 'eglot-ensure)

;; (defun eglot-format-buffer-on-save ()
;;   (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
;; (add-hook 'go-mode-hook #'eglot-format-buffer-on-save)

(setq eglot-workspace-configuration
      '((:gopls .
                (:directoryFilters ("-bazel-bin" "-bazel-out" "-bazel-testlogs" "-bazel-loltel")
                 :allowImplicitNetworkAccess t
                 :usePlaceholders t))))
#+end_src

* Crux setup

This adds a lot of nify utilities that I've been missing.

#+begin_src emacs-lisp
(use-package crux
  :bind (("C-o" . crux-smart-open-line-above)
         ("C-c d" . crux-duplicate-current-line-or-region)
         ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)))
#+end_src

* Look and feel

Set up the themes to use, and make it switch automatically to the system
appearence.

#+begin_src emacs-lisp
(use-package leuven-theme)
(use-package gruvbox-theme)
(use-package material-theme)

(defvar theme-sets
  '((leuven ((light . leuven) (dark . leuven-dark)))
    (gruvbox ((light . gruvbox-light-medium) (dark . gruvbox-dark-medium )))
    (material ((light . material-light) (dark . material)))))

(setq default-theme 'leuven)

(defun bn/adjust-face-attributes ()
;  (set-face-attribute 'markdown-table-face nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch))

(add-hook 'ns-system-appearance-change-functions #'bn/apply-theme)
#+end_src

Disable bookmark fontification, at least for now. They tend to spill over...

#+begin_src emacs-lisp
(setq bookmark-fontify nil)
#+end_src

Conserve space and reduce clutter.

#+begin_src emacs-lisp
(menu-bar-mode -1)
(global-unset-key (kbd "M-`"))
(if (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
(if (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+end_src

Fringes adds some air, and is nice for diff highlights etc.

#+begin_src emacs-lisp
(fringe-mode '(6 . 2))
#+end_src

This makes for a much prettier modeline.

#+begin_src emacs-lisp
(use-package powerline
  :defer nil
  :config (powerline-default-theme))
#+end_src

Mostly eliminate minor modes from the modeline. A better approach may be
minions-mode, but this is good /enough/ – for now at least.

#+begin_src emacs-lisp
(use-package diminish
  :config
  (diminish 'abbrev-mode)
  (diminish 'auto-fill-function)
  (diminish 'auto-fill-mode))
#+end_src

Start in full screen mode.

#+begin_src emacs-lisp
(toggle-frame-fullscreen)
#+end_src

I find transparency neat for about ten minutes...

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha . (100 . 100)))
#+end_src

Set up some nice fonts: Libre Baskerville nicer than Baskerville, and Fira Code
is neat plus it has a ton of vanity symbols.

#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Libre Baskerville" :height 130))))
 '(fixed-pitch ((t (:family "Fira Code" :height 120)))))
#+end_src

Why not?

#+begin_src emacs-lisp
(global-prettify-symbols-mode t)
#+end_src

Highligting the line the cursor is on makes it easier to  spot.

#+begin_src emacs-lisp
(global-hl-line-mode 1)
#+end_src

Define modes and related hooks used for writing prose.

#+begin_src emacs-lisp
(defvar prose-modes '(text-mode git-commit-mode markdown-mode))
(defvar prose-mode-hooks
  (mapcar (lambda (n) (intern (format "%s-hook" n)))
          prose-modes))
#+end_src

Set up prose modes with a variable pitch font. I'm still not sure about this,
but variable pitch fonts /are/ easier to read.

#+begin_src emacs-lisp
(dolist (h prose-mode-hooks)
  (add-hook h (lambda () (variable-pitch-mode 1))))
#+end_src

Prevent horizontal splits for big windows.

#+begin_src emacs-lisp
(setq split-height-threshold nil)
#+end_src

Winner mode allows switching between window configurations. It's a bit
simplistic, but until I find a better alternative, it's way better than noting.

#+begin_src emacs-lisp
(winner-mode 1)
#+end_src

Zoom mode allows me to continue using a three-way split when I disconnect the
monitor. It mostly works great.

#+begin_src emacs-lisp
(use-package zoom
  :diminish
  :init (setq zoom-size '(100 .  40))
  :config (zoom-mode 1))
#+end_src

No ugly line wrapping.

#+begin_src emacs-lisp
(set-default 'truncate-lines t)
#+end_src

I've never missed the bell, visible or otherwise.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

This improves the stock help mode a lot: Not only does it look better, it also
includes more information.

#+begin_src emacs-lisp
(use-package helpful
  :bind (("C-?"   . help-command)
         ("C-? f" . helpful-callable)
         ("C-? v" . helpful-variable)
         ("C-? k" . helpful-key)
         :map helpful-mode-map
         ("Q" . helpful-kill-buffers)
         ("g" . helpful-update)))
#+end_src

* Key bindings
** Settings
On Mac, map the command key to meta and keep the normal behaviour of option.

#+begin_src emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier nil)
#+end_src

This pops up a list of possible next keys in the minibuffer. It's incredibly
useful.

#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :config (which-key-mode 1))
#+end_src

** Personal keymaps

#+begin_src emacs-lisp
(define-prefix-command 'bn/search-map)
(bind-key  "C-c s" 'bn/search-map)

(define-prefix-command 'bn/editing-map)
(bind-key  "C-c e" 'bn/editing-map)

(define-prefix-command 'bn/buffer-map)
(bind-key  "C-x b" 'bn/buffer-map)

(define-prefix-command 'bn/window-map)
(bind-key  "C-c w" 'bn/window-map)
#+end_src

** Remove bindings
These are useless, or worse:

#+begin_src emacs-lisp
(mapcar (lambda (k) (global-unset-key (kbd k)))
        '("C-x C-r"  ; Find file read-only
          "C-x C-q"  ; Read-only mode
          "C-x C-d"  ; List directory
          ))
#+end_src

** New bindings

Global key bindings.

#+begin_src emacs-lisp
(bind-keys :map global-map
           ("C-<tab>" . other-window)
           ("C-S-<tab>" . bn/other-window-back)
           ("M-/" . hippie-expand))
#+end_src

Other window manipulation commands.

#+begin_src emacs-lisp
(bind-keys :map bn/window-map
           ("s" . window-swap-states))
#+end_src

Text manipulation commands.

#+begin_src emacs-lisp
(bind-keys :map bn/editing-map
           ("\\" . align-regexp)
           ("<SPC>" just-one-space))
#+end_src

Buffer manipulation:

#+begin_src emacs-lisp
(bind-keys :map bn/buffer-map
           ("b" . switch-to-buffer)
           ("s" . bn/buffer-same-mode)
           ("l" . list-buffers))
#+end_src

The ability  to move to the next/prev occurence of the current symbol
is something I missed after using IntelliJ for a while.

#+begin_src emacs-lisp
(use-package auto-highlight-symbol
  :diminish
; Does not work since use-package will try to load auto-highlight-symbol too
;  :hook ((prog-mode . auto-highlight-symbol-mode))
  :bind (("M-p" . ahs-backward)
         ("M-n" . 'ahs-forward))
  :init (setq ahs-idle-interval 1.0
              ahs-default-range 'ahs-range-whole-buffer
              ahs-inhibit-face-list '(font-lock-comment-delimiter-face
                                      font-lock-comment-face
                                      font-lock-doc-face
                                      font-lock-doc-string-face
                                      font-lock-string-face)))
#+end_src

Interactive regular expressions because I find it tricky to remember
the Emacs syntax for these.

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind (:map bn/search-map
              ("r" . 'vr/replace)
              ("q" . 'vr/query-replace)))
#+end_src

** Rebindings
Rebind ~C-h~, and use it for deleting backwards. I still consider this a bit of
an experiment...

#+begin_src emacs-lisp
(global-set-key (kbd "C-h") 'delete-backward-char)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

** Hydra
Hydra allows quickly repeating complex key bindings, as well as easily setting
up a simple menu beneath a key binding. I find this very useful for complex
movement commands in org-mode.

#+begin_src elisp
(use-package hydra)
(defhydra hydra-org-view-section (org-mode-map "C-c h")
  "View section under headline"
  ("n" bn/org-show-next-heading "next")
  ("p" bn/org-show-prev-heading "previous"))
(defhydra hydra-move-org-section (org-mode-map "C-c h")
  "Move section up or down"
  ("U" org-move-subtree-up "up")
  ("D" org-move-subtree-down "down"))
#+end_src

* Navigation
I used to rely on isearch for quick navigation. In many cases avy is even
quicker, though it requires more compute.

#+begin_src emacs-lisp
(use-package avy
  :bind (("C-," . avy-goto-word-1))
  :init (setq avy-keys
              '(?t ?n ?s ?e ?r ?i ?o ?a  ;; Home row fingers
                ?w ?f ?l ?u ?y ?\; ?d ?h ?x ?c ?v ?m ?, ?. ;; Close to home row; no pinkes
                ?g ?b ?j ?k ;; Diagonals
                ?q ?z ?p ?\/ ;; Pinkies away from the home row
                )))
#+end_src

* General editing setup

As a rule, I don't want to indent with tabs. Spaces are more predicable, and I
anyway leave it to Emacs most of the time.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

This permits replacing the contents of a selection by yanking text on top of it,
i.e. the normal behaviour since about 1990. Very useful.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Don't create backup or lock files. I've got TimeMachine for backups, and I'm
hopefully the sole user of my system.

#+begin_src emacs-lisp
(setq make-backup-files nil
      create-lockfiles nil)
#+end_src

Unconditionally auto-save all visited files every time Emacs loses focus. This
is a little dangerous, but so far so good...

#+begin_src emacs-lisp
(add-hook 'focus-out-hook
          (lambda ()
            (interactive)
            (save-some-buffers t)))
#+end_src

Some like having the lines numbered, but I find just showing it in the modeline
will usually suffice.

#+begin_src emacs-lisp
(column-number-mode t)
#+end_src

Improve parenthesis handling by highlighting matching ones.

#+begin_src emacs-lisp
(show-paren-mode t)
#+end_src

I want to treat CamelCase as separate words more often than not. Perhaps always.

#+begin_src emacs-lisp
(use-package subword
  :diminish
  :config (global-subword-mode 1))
#+end_src

Try to keep the whitespace under control. The whitespace butler seems to work
pretty well, but it needs an extra hook for org-capture for some reason.

#+begin_src emacs-lisp
(use-package ws-butler
  :diminish
  :init
  (setq require-final-newline t)
  :config
  (ws-butler-global-mode 1)
  (add-hook 'org-capture-mode-hook (lambda () (ws-butler-mode -1))))
#+end_src

Make regular expession alignment always use spaces and not tabs.

#+begin_src emacs-lisp
(defadvice align-regexp (around align-regexp-with-spaces activate)
  (let ((indent-tabs-mode nil))
    ad-do-it))
#+end_src

Getting the environment set correctly is/was a struggle on macOS. I've been
using this for a while, and it seems to work.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config (exec-path-from-shell-initialize))
#+end_src

While the default LANG setting seems to make sense, it causes locale warnings.

#+begin_src emacs-lisp
(setenv "LANG" "")
#+end_src

I just use ispell for now, but should look into a way of supporting multiple
dictionaries.

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/ispell")
#+end_src

In some cases, like YAML, indentation guides is a must.

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook (yaml-mode . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'bitmap
        highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

Seeing the real width of the cursor is sometimes useful (e.g. tabs).

#+begin_src emacs-lisp
(setq x-stretch-cursor t)
#+end_src

I quite frequently want to go back to the last edited location. This package
handles that, and also allows to jump to all past edited locations.

#+begin_src emacs-lisp
(use-package goto-last-change
    :bind (("C-;" . goto-last-change)))
#+end_src

It's common to want to mark the region the cursor is currently in. This package
allows selecting increasingly wide regions around the cursor.

#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region))
#+end_src

* Searching and filtering
Consult is swiper on steroids.

#+begin_src emacs-lisp
(use-package consult
  :bind
  (("M-y" . consult-yank-pop)    ; like yank pop, but also shows preview
   :map bn/search-map
   ("n" . consult-find)          ; (f)ind file
   ("g" . consult-ripgrep)       ; (g)rep files
   ("s" . consult-line)          ; (s)earch for line
   ("i" . consult-imenu)         ; (i)menu completions
   ("j" . consult-mark)          ; (j)ump to mark
   ("f" . consult-focus-lines))  ; (f)ilter lines
  :init
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref))
#+end_src

I often switch from Emacs to searh  for stuff.  Let's put an end to that!

#+begin_src emacs-lisp
(use-package ripgrep
  :defer 15)
#+end_src

* Integrations

Use projectile. This is quite neat in normal projects, but it's struggling in
big monorepos. Hmm.

#+begin_src emacs-lisp
(use-package projectile
  :init (setq projectile-project-search-path '(("~/Contexts/WG2/src" . 2)
                                               "/Users/bn/.emacs.d"
                                               "~/src/forks/qmk_firmware"))
  :bind-keymap ("C-c p" . projectile-command-map)
  :config (projectile-mode +1))
#+end_src

It seems I'm practically living inside Emacs these days, so I might as well use
it as an entry-point for various web searches.

#+begin_src emacs-lisp
(use-package engine-mode
    :defer 15
    :config (engine-mode))

(defengine duckduckgo
  "https://www.duckduckgo.com/?q=%s"
  :keybinding "d")

(defengine github-loltel-issue-lookup
  "https://github.com/omnicate/loltel/issues/%s"
  :keybinding "i")

(defengine github-loltel-issue-search
  "https://github.com/omnicate/loltel/issues?q=is:issue+is:open+%s"
  :keybinding "s")

(defengine github-loltel-issue-label
  "https://github.com/omnicate/loltel/issues?q=is:issue+is:open+label:%s"
  :keybinding "l")
#+end_src

Elfeed seems to be the best choice for RSS feeds today, and also supports
defining the feeds in org! I could probably point it to the roam directory and
have it pick up all the feeds based on tags, but that seems a bit extreme...

#+begin_src emacs-lisp
(use-package elfeed-org
  :disabled t
  :defer 15
  :init
  (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
  :config
  (elfeed-org))
#+end_src

Pick up authentication info.

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo"))
#+end_src

In practice I hardly ever answer anything but yes.

#+begin_src emacs-lisp
(setq confirm-kill-processes nil)
#+end_src

Integration with reveal.js. Along with org-mode and ditaa, this is a pretty
powerful way of making presentations.

#+begin_src emacs-lisp
(use-package ox-reveal
  :init (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
(use-package htmlize)
#+end_src

** Eshell

I have a somewhat troubled relationship with eshell. On one side it's quite neat
and convenient, ong the other hand it too frequently falls apart and I have to
switch to a terminal.

#+begin_src emacs-lisp
(use-package eshell
  :config (toggle-truncate-lines -1))
#+end_src

** PlantUML

PlantUML not as neat as websequencediagrams, but who cares when the Emacs
support is so great! I'm a bit confused about how plantuml-mode relates to
ob-plantuml though. The latter is bundled with Emacs, and requires the fragile
JAR setting below. But it also seems to be more freqently updated.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :init
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  (setq plantuml-executable-path "/usr/local/bin/plantuml"
        org-plantuml-jar-path "/usr/local/Cellar/plantuml/1.2022.4/libexec/plantuml.jar"
        plantuml-default-exec-mode 'executable))
#+end_src

* Programming language support

Some useful defaults for all programming languages.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'electric-pair-local-mode)
(add-hook 'prog-mode-hook 'electric-indent-local-mode)
(add-hook 'prog-mode-hook 'auto-highlight-symbol-mode)
#+end_src

This works surprisingly well for navigating code, even in big monorepos.
  
#+begin_src emacs-lisp
(use-package dumb-jump
  :config
  (setq xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** Erlang

#+begin_src emacs-lisp
(use-package erlang
  :config
  (add-to-list 'erlang-tags-file-list "~/src/bn/loltel/terminators/erlang/TAGS"))
#+end_src

** Go

This sets up Go mode with some basic support. The jump to definition support is
limited, unfortunately.

#+begin_src emacs-lisp
(use-package go-eldoc)

(use-package go-mode
  :hook (before-save . gofmt-before-save)
  :init
  (exec-path-from-shell-copy-env "GOPATH")
  (setq go-eldoc-gocode "/Users/bn/go/bin/gocode")
  (add-hook 'go-mode-hook
            (lambda ()
              (setq tab-width 4)
              (subword-mode 1)
              (go-eldoc-setup)
              (setq imenu-generic-expression
                    '(("func" "^func +\\(\\(?:([^)]+) \\)?[a-zA-Z][a-zA-Z0-9_]+\\)(" 1)
                      ("type" "^type +\\([a-zA-Z][a-zA-Z0-9_]+\\)\\s-" 1))))))

(use-package go-fill-struct)
(use-package go-playground
  :defer 15)
#+end_src

** Elisp
From what I hear paredit is passé, and Lispy is the new kid on the block, but
I gave up and reverted to paredit.

#+begin_src emacs-lisp
(use-package paredit
  :diminish
  :hook (emacs-lisp-mode . paredit-mode))

(use-package prism
  :if window-system
  :hook (emacs-lisp-mode . prism-mode))

(use-package eldoc
  :diminish
  :hook emacs-lisp-mode)

(use-package elisp-def
  :diminish
  :hook (emacs-lisp-mode . elisp-def-mode))
#+end_src

** Shell

#+begin_src emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (setq sh-basic-offset 4
                  sh-indentation 4)))
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Graphviz

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :init (setq graphviz-dot-view-command "xdot %s"))
#+end_src

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode
  :init
  (add-hook 'haskell-mode-hook 'subword-mode)
  (add-hook 'haskell-mode-hook 'haskell-doc-mode)
  (add-hook 'haskell-mode-hook #'lsp)
  (setq lsp-haskell-server-path (expand-file-name "~/.ghcup/bin/haskell-language-server-wrapper")))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode
  :disabled t
  :init
  (setq racer-cmd "~/bin/racer"
        racer-rust-src-path "~/src/thirdparty/rust/src"
        company-tooltip-align-annotations t)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
  (add-hook 'rust-mode-hook 'racer-mode)
  (add-hook 'racer-mode-hook 'company-mode))
#+end_src

** C
#+begin_src emacs-lisp
(setq c-basic-offset 4)
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :init
  (setq markdown-open-command "~/bin/mark")
  (add-hook 'markdown-mode-hook 'visual-line-mode))
#+end_src

** Yaml

#+begin_src emacs-lisp
(use-package yaml-mode
  :init (add-hook 'yaml-mode-hook (lambda () (variable-pitch-mode -1))))
#+end_src

** XML

#+begin_src emacs-lisp
;;(set-face-attribute 'nxml-element-local-name nil :inherit 'fixed-pitch)
#+end_src

** Bazel

#+begin_src emacs-lisp
(use-package bazel
  :bind
  (("C-c b f b" . bazel-find-build-file)
   ("C-c b t p" . bazel-test-at-point)))
#+end_src

** Rego

Syntax highlighting and REPL support for OPAs Rego configuration language.

#+begin_src emacs-lisp
(use-package rego-mode
  :init
  (add-hook 'rego-mode-hook (lambda ()
                              (setq tab-width 4)))
  :custom
  (rego-repl-executable "/Users/bn/.nix-profile/bin/opa")
  (rego-opa-command "/Users/bn/.nix-profile/bin/opa"))
#+end_src

** Protobuf

#+begin_src emacs-lisp
(use-package protobuf-mode
  :hook (protobuf-mode . (lambda ()
                           (setq c-basic-offset 2))))
#+end_src

** Terraform

#+begin_src emacs-lisp
(use-package terraform-mode)
#+end_src

** Java
#+begin_src elisp
(add-hook 'java-mode-hook (lambda () (setq c-basic-offset 2)))
#+end_src

** Nix
#+begin_src elisp
(use-package nix-mode)
#+end_src

* Completion

I used to use Helm, but switched to Vertico because I like it's modular
approach, and integration with the default completion system. And after all I
only used a fraction of Helm's functionality...

#+begin_src emacs-lisp
(use-package vertico
  :init (vertico-mode))
#+end_src

The directory extension makes Vertico behave more like Ido, which I find more
pleasant.

#+begin_src emacs-lisp
(use-package vertico-directory
  :load-path "~/src/forks/vertico/extensions"
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

The orderless completion package is snappy and matches just the way I want.

#+begin_src emacs-lisp
(use-package orderless
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

Marginalia decorates the completion listings neatly with additional information
such as docstrings.

#+begin_src emacs-lisp
(use-package marginalia
  :bind (:map minibuffer-local-map
              ("M-a" . marginalia-cycle))
  :init (marginalia-mode))
#+end_src

Embark works a bit like a context menu that can be used anywhere. I kind of like
the idea, but so far I haven't used it a lot.

#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-. ." . embark-act)
   ("C-. ," . embark-dwim))
  :init
  (setq prefix-help-command #'embark-prefix-help-commant))
#+end_src

* Org mode
Load the org-mode and do basic configuration:

- Set up global keybindings.
- Clear some local keybindings that gets in the way.
- Also switch on auto-fill-mode in order to make prose easier to write.
- Ensure tables and blocks are still in monospace.
#+begin_src emacs-lisp
(use-package org
  :after diminish org-superstar
  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c l" . org-store-link)
         ("C-c C-x C-j" . org-clock-goto)
         ("C-. o j" . org-clock-goto)
         ("C-. o o" . org-clock-out)
         :map org-mode-map
         ("C-," . nil)
         ("C-c t" . org-todo)
         ("C-c M-p" . org-move-subtree-up)
         ("C-c M-n" . org-move-subtree-down)
         ("C-c <down>" . org-move-item-down)
         ("C-c <down>" . org-move-item-up)
         ("C-x n w" . org-toggle-narrow-to-subtree)
         ("C-. h" . consult-org-heading)
         ("C-<tab>" . nil)
         ("M-h" . nil)
         ("C-˜" . bn/org-show-next-heading)
         ("C-∏" . bn/org-show-prev-heading)
         ("C-c h n" . bn/org-show-next-heading)
         ("C-c h p" . bn/org-show-prev-heading))
  :init
  (setq org-startup-folded 'show2levels
        org-edit-src-content-indentation 0
        org-src-fontify-natively t
        org-src-window-setup 'current-window
        org-clock-idle-time 10
        org-clock-in-switch-to-state "NEXT"
        org-clock-out-remove-zero-time-clocks t
        org-clock-out-when-done t
        org-goto-interface 'outline-path-completion
        org-outline-path-completion-in-steps nil
        org-modules '(ol-w3m ol-bibtex ol-docview ol-info ol-mhe)
        org-fontify-whole-heading-line t
        org-use-sub-superscripts "{}"
        org-M-RET-may-split-line nil
        org-ditaa-jar-path "/Users/bn/.emacs.d/ditaa.jar")
  (add-hook 'org-mode-hook
            (lambda ()
              (auto-fill-mode 1)
              (org-indent-mode 1)
              (electric-indent-local-mode -1)
              (electric-pair-local-mode 1)
              (diminish 'org-indent-mode)
              (diminish 'buffer-face-mode))))
#+end_src

Automatically save the buffer after clocking in/out:

#+begin_src emacs-lisp
(advice-add 'org-clock-in :after #'save-buffer)
(advice-add 'org-clock-out :after #'save-buffer)
#+end_src

Set up fast selection for tags. Lots of them! Lowercase characters are for
categories, uppercase for contexts, including people. I could perhaps switch to
digits for contexts if clashes become a problem..

#+begin_src emacs-lisp
(setq org-tag-alist '(("admin" . ?a)
                      ("emacs" . ?e)
                      ("integrators" . ?i)
                      ("mdg" . ?m)
                      ("org" . ?o)
                      ("read" . ?r)
                      (:newline)
                      ("easy" . ?z)
                      ("hard" . ?h)
                      (:newline)
                      ("@home" . ?H)
                      ("@standup" . ?S)))
#+end_src

Properties that should be set across the board.

#+begin_src emacs-lisp
(setq org-global-properties
      '(("Effort_ALL" . "0:10 0:30 1:00 2:00 4:00 7:00")))
#+end_src

For the column view, I'd like to see the basics as compact as possible.

#+begin_src emacs-lisp
(setq org-columns-default-format
      "%40ITEM(Task) %9TODO(State) %6Effort(Effort){:} %6CLOCKSUM(Sum) %ALLTAGS(Tags)")
#+end_src

** Some basic settings
I keep most of the stuff under ~Repository/Org~. For now fleeting notes are
recorded in an Inbox, which is a relic from an older GTD structure. Items are
archived in datetrees per file to retain context..

#+begin_src emacs-lisp
(setq org-directory "~/Repository/Org"
      org-default-notes-file "~/Repository/Org/Tasks.org"
      org-archive-location "%s_archive::datetree/"
      org-agenda-restore-windows-after-quit t
      org-agenda-window-setup 'current-window
      org-log-done 'time
      org-log-redeadline nil
      org-log-reschedule nil
      org-read-date-prefer-future 'time)
#+end_src

I started out with a pretty complex set  of keywords, then added more. In the
end I used very few, and they can be distilled down to this list.

- TODO for tasks that has not yet been completed.
- DONE for completed tasks.
- BLOCKED for tasks where I'm waiting for someone or something.
- CANCELLED for tasks I gave up doing.

#+begin_src emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)" "DONE(d)" "BLOCKED(b@)" "CANCELLED(c@)")))
#+end_src

Emacs Lisp is a popular source language, so give it  its own key. As both "e"
and "E" are taken, it will have to live under "m".

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("m" . "src emacs-lisp"))
#+end_src

Exporting to Slack allows me to edit the message in e.g. an org-mode note.

#+begin_src emacs-lisp
(use-package ox-slack
  :defer 10)
#+end_src

I prefer sparse trees to only show the matched entries. This fixes that in most cases.

#+begin_src emacs-lisp
(add-to-list 'org-show-context-detail '(tags-tree . local))
#+end_src

** Appearence
Makes heading and lists somewhat prettier.

#+begin_src emacs-lisp
(use-package org-superstar
  :init
  (add-hook 'org-mode-hook 'org-superstar-mode))
#+end_src

Make it look less like markup. This goes well with a variable pitch font.

#+begin_src emacs-lisp
(customize-set-value 'org-hide-emphasis-markers t)
(customize-set-value 'org-pretty-entities t)
(customize-set-value 'org-ellipsis "…")
#+end_src

**  Editing and navigation

#+begin_src emacs-lisp
(customize-set-value 'org-auto-align-tags nil)
(customize-set-value 'org-tags-column 0)
(customize-set-value 'org-catch-invisible-edits 'show-and-error)
(customize-set-value 'org-special-ctrl-a/e t)
(customize-set-value 'org-insert-heading-respect-content t)
#+end_src

** Extras
Support for pasting and dropping images. Setting ~org-image-actual-width~ to
~nil~ allows specifying e.g. ~#+org_attr: :width 600~ to limit the width of the
image, otherwise they sometimes appear very wide.

#+begin_src emacs-lisp
(use-package org-download
  :defer 5
  :init
  (setq org-image-actual-width nil
        org-download-image-dir "~/Repository/Org/Images"))
#+end_src

This allows bookmarking org headings using ~C-x r m~.

#+begin_src emacs-lisp
(use-package org-bookmark-heading)
#+end_src

** Exporting
Don't prompt when evaluating ditaa code blocks.

#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate
      (lambda (lang body)
        (not (member lang '("ditaa" "plantuml" "bash" "dot")))))
#+end_src

Enable more languages.

#+begin_src emacs-lisp
(use-package ob-go)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((ditaa . t)
   (plantuml . t)
   (emacs-lisp . t)
   (shell . t)
   (go . t)
   (dot . t)))
#+end_src

** Pomodoro
#+begin_src emacs-lisp
(use-package org-pomodoro
  :init (setq org-pomodoro-length 20))
#+end_src

** Contacts

It's easy to just stuff contacts into some random address book (GMail, your
phone, ...), but let's take a step back: Contacts are /people/ that you deal
with. Many of them you will deal with for years or decades. They should not just
be thrown into an address book as an afterthought.

#+begin_src emacs-lisp
; 20210427 Seems unavailable?
;(use-package org-contacts
;  :after org
;  :custom (org-contacts-files '("~/Repository/Org/People.org")))
#+end_src

** Bookmarks
Cliplink makes it easy to capture URLs with a title. I mostly use it with the
bookmark capture template, but sometimes it's nice to get a link with the full
title, e.g. for project references.

#+begin_src emacs-lisp
(use-package org-cliplink
  :bind (:map org-mode-map
              ("C-c M-l" . org-cliplink)))
#+end_src

** Agenda setup
The current system is very simple: I have all my tasks in Tasks.org. This file
has three sections:

- Ongoing :: Up to eight tasks I have started working on.
- Blocked :: Tasks which cannot continue, e.g. because I'm waiting for someone.
- Incoming :: Tasks I have not started working on (and probably never will).

I might add sections for completed tasks, and perhaps also for tasks I decided
/not/ to do.

#+begin_src emacs-lisp
(setq org-agenda-files '("~/Repository/Org/Tasks.org"))
#+end_src

The agenda has views for the inbox, all my next actions, and all my projects.
But I'm planning to incorporate all of this information in one view, currently
dubbed "review".

#+begin_src emacs-lisp
(setq org-agenda-custom-commands nil)
#+end_src

Start agenda on the current day rather than the first day of the week.

#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday nil)
#+end_src

** Capture and refile

#+begin_src emacs-lisp
(setq org-capture-templates
      `(("t" "TODO" entry (file+headline org-default-notes-file "Incoming")
         "** TODO %i%?")
        ("b" "Bookmark" entry (file "~/Bookmarks.org")
         "* %(org-cliplink-capture)\n%U\n%?" :empty-lines 1)
        ("s" "Standup" plain (file+olp+datetree "WG2SubscriberState.org" "Standups")
         (file "~/.emacs.d/templates/standup-capture.org")
         :immediate-finish t
         :jump-to-captured t)
        ("c" "Contact" entry (file "Contacts.org")
         (file "~/.emacs.d/templates/contact-capture.org"))))
#+end_src

I've dumbed down the refiling targets to just consider all the agenda files at
level one.

#+begin_src emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 5)
                           (org-agenda-files :maxlevel . 2)))
#+end_src


* Thinking with org-roam
I use org-roam in a different way than plain Org, so it makes sense to keep it
as a separate top-level directory.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Repository/Roam")
#+end_src

Set up org-roam v2 behind the ~C-c n~ prefix:

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :bind
  (("C-c n f" . org-roam-node-find)
   ("C-c n j j" . org-roam-dailies-capture-today)
   ("C-c n j t" . org-roam-dailies-goto-today)
   ("C-c n j y" . org-roam-dailies-goto-yesterday)
   ("C-c n j d" . org-roam-dailies-goto-date)
   :map org-mode-map
   ("C-c n i" . org-roam-node-insert)
   ("C-c n l" . org-roam-buffer-toggle)
   ("C-c n x" . org-roam-node-random)
   ("C-c n a a" . org-roam-alias-add)
   ("C-c n a r" . org-roam-alias-remove)
   ("C-c n r a" . org-roam-ref-add)
   ("C-c n r r" . org-roam-ref-remove)
   ("C-c n t a" . org-roam-tag-add)
   ("C-c n t r" . org-roam-tag-remove))
  :init (setq org-roam-v2-ack t)
  :custom
  (org-roam-node-display-template "${title:*} ${tags:20}" "Widen the tag column")
  (org-roam-capture-templates '(("d" "Default" plain "%?"
                                 :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                                    "#+date: %T\n#+title: ${title}\n")
                                 :unnarrowed t)
                                ("r" "Read" plain (file "~/.emacs.d/templates/book-capture.org")
                                 :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                                    "#+title: ${title}\n#+date %T\n#+filetags: Lit")
                                 :unnarrowed t)))
  :config
  (org-roam-setup))
#+end_src

I switched from org-journal to org-roam-dailies as I don't use any of the bells
and whistles of the former, and this integrates better with org-roam.

#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         "* %?"
         :if-new (file+head "%<%Y-%m-%d>.org"
                            "#+title: %<%Y-%m-%d>\n"))))
#+end_src

This package enables preview for ripgrep, forward /and/ backwards links – and
more!

#+begin_src emacs-lisp
(use-package consult-org-roam)
#+end_src

* Reading and research
Allows fetching RFCs by number, or browsing with completion. This is good for
quickly looking up stuff, while for serious reading pulling the PDF and using
org-noter is preferrable. Pity it doesn't work with plain text...

#+begin_src emacs-lisp
(use-package rfc-mode)
#+end_src

PDF tools is great for reading, and annotating PDFs. I mostly use it together
with org-noter.

#+begin_src emacs-lisp
(use-package pdf-tools
  :mode ("\\.pdf\\'" . pdf-view-mode)
  :demand
  :config
  (pdf-tools-install :no-query))

(use-package org-pdftools
  :hook (org-load . org-pdftools-setup-link))
#+end_src

This allows reading ebooks too. I could never get it working properly with
org-noter, but last time I checked it seemed to work. Not something I use a lot
as most of my reading is PDFs.

#+begin_src emacs-lisp
(use-package nov
  :disabled
  :mode ("\\.\\(epub\\|mobi\\)\\'" . nov-mode))
#+end_src

I find org-noter incredibly useful for research.

#+begin_src emacs-lisp
(use-package org-noter
  :after org-roam
  :bind (("C-c n o" . org-noter)
         :map org-noter-doc-mode-map
         (("M-i" . zp/org-noter-insert-precise-note-dwim)))
  :init
  (setq org-noter-notes-search-path (list org-roam-directory)
        org-noter-notes-window-location 'horizontal-split))

(use-package org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

* Version control

Bind magit to ~C-x g~, and unbind ~C-<tab>~ since it's used for switching
buffers.

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-x g" . magit)
         :map magit-mode-map
         ("C-<tab>" . nil))
  :init (setq magit-git-executable "/Users/bn/.nix-profile/bin/git"
              magit-log-margin '(t "%+4Y%m%dT%T" magit-log-margin-width t 18)))
#+end_src

Forge hooks into magit and provides access to GitHub. It's slow on the monorepo
at work, but reducing the topic list limit seems to help.

#+begin_src emacs-lisp
(use-package forge
  :after magit
  :init
  (setq forge-topic-list-limit '(17 .  3)))
#+end_src

This allows visiting the current file in the remote repo. Useful for giving others references to
code.

#+begin_src emacs-lisp
(use-package git-link)
#+end_src

It is neat and sometimes quite useful to see the changes since last commit in the buffer margin.

#+begin_src emacs-lisp
(use-package diff-hl
  :hook '((prog-mode . turn-on-diff-hl-mode)
          (vc-dir-mode . turn-on-diff-hl-mode)))
#+end_src

Finally, reduce the GC threshold a bit to make the user experience better.

#+begin_src emacs-lisp
(setq gc-cons-threshold (* 4 1000 1000))
#+end_src
