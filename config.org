* Basic initialisation
** Load extra files

Load various add-on functionality.

#+begin_src emacs-lisp
(load-file "~/.emacs.d/elisp/bn.el")
(load-file "~/.emacs.d/elisp/org-tags.el")
#+end_src

** Configure package installation

Automatically ensure packages are installed if they are not already there.

#+begin_src emacs-lisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+end_src

Ensure packages are always compiled, and that the latest version available is
used.

#+begin_src emacs-lisp
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+end_src

** General defaults

Who wouldn't want sensible defaults?

#+begin_src emacs-lisp
(load-file "~/.emacs.d/sensible-defaults.el")
(sensible-defaults/use-all-settings)
#+end_src

** Servers

Start emacs-server for integrating neatly with the shell.

#+begin_src emacs-lisp
(use-package server)
(if (not (server-running-p))
  (server-start))
#+end_src

* Experiments

This section is for testing out new configurations.

#+begin_src emacs-lisp
(global-hl-line-mode 1)
;(setq org-src-fontify-natively t)
(setq org-src-window-setup 'current-window)
;(setq org-adapt-indentation nil)
; "Breaks" if projectile is not loaded
;(setq frame-title-format '((:eval (projectile-project-name))))
#+end_src

* Look and feel

While I find dark themes more aesthetically pleasing, bright ones are more
ergonomic.

#+begin_src emacs-lisp
(use-package leuven-theme)
#+end_src

Conserve space and reduce clutter.

#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(when (window-system)
  (scroll-bar-mode -1))
#+end_src

I don't think I've ever had any use of seeing the minor modes in the mode line.
This saves a lot of space that I can surely find some other use for.

#+begin_src emacs-lisp
(use-package minions
  :config
  (setq minions-mode-line-lighter ""
        minions-mode-line-delimiters '("" . ""))
  (minions-mode 1))
#+end_src

Run in full screen mode. On Mac this no longer creates a new desktop, but rather
an undecorated, maximised frame. It's a bit funky, but I have not had time to
look into it yet.

#+begin_src emacs-lisp
(toggle-frame-fullscreen)
#+end_src

I find transparency neat for about ten minutes...

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha . (100 . 100)))
#+end_src

Incosolata LGC Markup as it has more glyphs (like em dash) than InconsolataGo.
Libre Baskerville is as nice as Baskerville, and easier to read on the screen.

#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(variable-pitch ((t (:family "Libre Baskerville" :height 130))))
 '(fixed-pitch ((t (:family "Inconsolata LGC Markup" :height 130)))))
#+end_src

Why not?

#+begin_src emacs-lisp
(global-prettify-symbols-mode t)
#+end_src

Define modes and related hooks used for writing prose.

#+begin_src emacs-lisp
(defvar prose-modes '(text-mode git-commit-mode markdown-mode))
(defvar prose-mode-hooks
  (mapcar (lambda (n) (intern (format "%s-hook" n)))
          prose-modes))
#+end_src

Set up prose modes with a variable pitch font. I'm still not sure about this,
but variable pitch fonts /are/ easier to read.

#+begin_src emacs-lisp
(dolist (h prose-mode-hooks)
  (add-hook h (lambda () (variable-pitch-mode 1))))
#+end_src

Prevent horizontal splits for big windows.

#+begin_src emacs-lisp
(setq split-height-threshold nil)
#+end_src

Zoom mode allows me to continue using a three-way split when I disconnect the
monitor. It mostly works great.

#+begin_src emacs-lisp
(zoom-mode 1)
(setq zoom-size '(100 .  40))
#+end_src

No ugly line wrapping.

#+begin_src emacs-lisp
(set-default 'truncate-lines t)
#+end_src

I've never missed the bell, visible or otherwise.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

Auto-highlighting the current symbol can be quite useful, not only when
programming.

#+begin_src emacs-lisp
(setq ahs-idle-interval 1.0
      ahs-default-range 'ahs-range-whole-buffer
      ahs-inhibit-face-list '(font-lock-comment-delimiter-face
                              font-lock-comment-face
                              font-lock-doc-face
                              font-lock-doc-string-face
                              font-lock-string-face))
#+end_src

* General editing setup

As a rule, I don't want to indent with tabs. Spaces are more predicable, and I
anyway leave it to Emacs most of the time.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

This eliminates all the tilde suffixed files. I've got TimeMachine for backups.

#+begin_src emacs-lisp
(setq backup-inhibited t)
#+end_src

Unconditionally auto-save all visited files every time Emacs loses focus.

#+begin_src emacs-lisp
(add-hook 'focus-out-hook
          (lambda ()
            (interactive)
            (save-some-buffers t)))
#+end_src

Automatically saving files is useful, but this had some side effects I can't
quite recall. Experiment more.

#+begin_src emacs-lisp
;(auto-save-visited-mode t)
;(setq auto-save-visited-interval 45)
#+end_src

Some like having the lines numbered, but I find just showing it in the modeline
will usually suffice.

#+begin_src emacs-lisp
(column-number-mode t)
#+end_src

Improve parenthesis handling by highlighting matching ones.

#+begin_src emacs-lisp
(show-paren-mode t)
#+end_src

Try to keep the whitespace under control. The whitespace butler seems to work
pretty well, but it needs an extra hook for org-capture for some reason.

#+begin_src emacs-lisp
(add-hook 'org-capture-mode-hook (lambda () (ws-butler-mode -1)))
(setq require-final-newline t)
#+end_src

Make regular expession alignment always use spaces and not tabs.

#+begin_src emacs-lisp
(defadvice align-regexp (around align-regexp-with-spaces activate)
  (let ((indent-tabs-mode nil))
    ad-do-it))
#+end_src

Getting the environment set correctly is/was a struggle on macOS. I've been
using this for a while, and it seems to work.

#+begin_src emacs-lisp
(exec-path-from-shell-initialize)
#+end_src

I just use ispell for now, but should look into a way of supporting multiple
dictionaries.

#+begin_src emacs-lisp
(setq ispell-program-name "/usr/local/bin/ispell")
#+end_src

In some cases, like YAML, indentation guides is a must.

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook (yaml-mode . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'bitmap
        highlight-indent-guides-bitmap-function 'highlight-indent-guides--bitmap-line))
#+end_src

* Integrations

I often switch from Emacs to searh  for stuff.  Let's put an end to that!

#+begin_src emacs-lisp
(use-package ripgrep)
#+end_src

Use projectile. This is quite neat in normal projects, but it's struggling in
big monorepos. Hmm.

#+begin_src emacs-lisp
(use-package projectile
  :bind (("C-c p" . projectile-command-map)))
#+end_src

It seems I'm practically living inside Emacs these days, so I might as well use
it as an entry-point for various web searches.

#+begin_src emacs-lisp
(use-package engine-mode)
(engine-mode 1)

(defengine qwant
  "https://www.qwant.com/?q=%s"
  :keybinding "q")

(defengine github-loltel-issue-lookup
  "https://github.com/omnicate/loltel/issues/%s"
  :keybinding "i")

(defengine github-loltel-issue-search
  "https://github.com/omnicate/loltel/issues?q=is%%3Aissue+is%%3Aopen+%s"
  :keybinding "s")
#+end_src

Elfeed seems to be the best choice for RSS feeds today, and also supports
defining the feeds in org! I could probably point it to the roam directory and
have it pick up all the feeds based on tags, but that seems a bit extreme...

Getting warning:

In end of data:
elfeed-org.el:385:1:Warning: the following functions are not known to be
    defined: org-element-map, org-element-parse-buffer, org-element-property,
    org-element-put-property

#+begin_src emacs-lisp
(use-package elfeed-org
  :init
  (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
  :config
  (elfeed-org))
#+end_src

* Programming language support

** Go

This sets up Go mode with some basic support.  The jump to definition
support is extremely limited, unfortunately.

#+begin_src emacs-lisp
(use-package go-mode
  :bind (("M-." . godef-jump))
  :hook (before-save . gofmt-before-save)
  :init
  (exec-path-from-shell-copy-env "GOPATH")
  (setq go-eldoc-gocode "/Users/bn/go/bin/gocode")
  :config
  (setq tab-width 4)
  (auto-highlight-symbol-mode 1)
  (electric-pair-mode 1)
  (electric-indent-mode 1)
  (subword-mode 1)
  (yas-minor-mode 1))

(use-package go-eldoc
  :config
  (go-eldoc-setup))

(use-package go-add-tags)
(use-package go-fill-struct)
(use-package go-playground)
#+end_src

** Elisp

   From what I hear paredit is pass√©, and Lispy is the new kid on the block.

#+begin_src emacs-lisp
  (use-package lispy)
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-delimiters)
  (use-package eldoc)

  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (lispy-mode 1)
              (rainbow-delimiters-mode 1)
              (eldoc-mode 1)))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)))
#+end_src

** Shell

#+begin_src emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (setq sh-basic-offset 2
                  sh-indentation 2)))
#+end_src

** Graphviz

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :init (setq graphviz-dot-view-command "xdot %s"))
#+end_src

** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode)

(add-hook 'haskell-mode-hook
          (lambda ()
            (subword-mode 1)
            (electric-pair-local-mode 1)
            (haskell-doc-mode 1)))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-mode)

(setq racer-cmd "~/bin/racer"
      racer-rust-src-path "~/src/thirdparty/rust/src"
      company-tooltip-align-annotations t)

(add-hook 'rust-mode-hook
          (lambda ()
            (cargo-minor-mode 1)
            (electric-pair-local-mode 1)
            (racer-mode 1)))

(add-hook 'racer-mode-hook
          (lambda ()
            (company-mode 1)))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :config
  (setq markdown-open-command "~/bin/mark")
  (set-face-attribute 'markdown-table-face nil :inherit 'fixed-pitch)
  (add-hook 'markdown-mode-hook (lambda () (visual-line-mode 1))))
#+end_src

** Yaml

#+begin_src emacs-lisp
(use-package yaml-mode
  :config
  (add-hook 'yaml-mode-hook
            (lambda ()
              (variable-pitch-mode -1)
              (electric-indent-mode 1))))
#+end_src

** Bazel

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("BUILD\\'" . bazel-mode))
#+end_src

* Helm

#+begin_src emacs-lisp
(use-package helm
  :bind (("C-h" . nil)
         ("M-x" . helm-M-x)
         ("C-x b" . helm-buffers-list)
         ("C-x M-b" . helm-recentf)
         ("C-x r b" . helm-filtered-bookmarks)
         ("C-x C-f" . helm-find-files)
         ("C-x 4 f" . find-file-other-window)
         ("C-c C-w" . org-refile)))
; I really don't get why this is needed. If it's not there, some targets, such
; as org-refile, does not seem to cause helm to be loaded/used.
(helm-mode 1)
#+end_src

#+begin_src emacs-lisp
(use-package helm-descbinds
  :after helm
  :config
  (helm-descbinds-mode 1))
#+end_src

Using Helm for projectile is great, but for some reason it barfs if I do not
bind "C-c" first.

#+begin_src emacs-lisp
(define-key global-map (kbd "C-c") (make-sparse-keymap))
(use-package helm-projectile
  :bind ("C-c p h" . helm-projectile))
#+end_src

* Key bindings

On Mac, map the command key to meta and keep the normal behaviour of
option.

#+begin_src emacs-lisp
(setq mac-command-modifier 'meta
      mac-option-modifier nil)
#+end_src

#+begin_src emacs-lisp
(use-package which-key
  :config
  (which-key-mode 1))
#+end_src

I picked up C-TAB switcing from Eclipse way back.  The reverse one is
perhaps overdoing it since I usually have no more than three buffers.

#+begin_src emacs-lisp
(global-set-key (kbd "C-<tab>")   'other-window)
(global-set-key (kbd "C-S-<tab>") 'bn/other-window-back)
(global-set-key (kbd "C-c m") 'bn/next-line-and-indent)
#+end_src

Bind a few useful functions.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x \\")	    'align-regexp)
(global-set-key (kbd "C-x C-<SPC>") 'just-one-space)
#+end_src

Some stuff I missed after making an attempt at TextMate a while back.

#+begin_src emacs-lisp
(global-move-dup-mode t)
(global-set-key (kbd "C-x C-d") 'md-duplicate-down)
(global-unset-key (kbd "C-M-<up>"))
(global-unset-key (kbd "C-M-<down>"))
#+end_src

This allows quickly jumping to words in a buffer.  Awsum!

#+begin_src emacs-lisp
(global-set-key (kbd "C-M-j") 'ace-jump-mode)
#+end_src

I still consider this a bit of an experiment...

#+begin_src emacs-lisp
(global-set-key (kbd "C-?") 'help-command)
; Find another key for this.
;(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "C-h") 'delete-backward-char)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

The ability  to move to the next/prev occurence of the current symbol
is something I missed after using IntelliJ for a while.

#+begin_src emacs-lisp
(load-library "auto-highlight-symbol")
(define-key auto-highlight-symbol-mode-map (kbd "M-p") 'ahs-backward)
(define-key auto-highlight-symbol-mode-map (kbd "M-n") 'ahs-forward)
#+end_src

Interactive regular expressions because I find it tricky to remember
the Emacs syntax for these.

#+begin_src emacs-lisp
(define-key global-map (kbd "C-c r") 'vr/replace)
(define-key global-map (kbd "C-c q") 'vr/query-replace)
#+end_src

I tend to think snippets are kind of silly (why would you keep typing
the same thing?), but with Go it becomes useful...

#+begin_src emacs-lisp
(global-set-key (kbd "C-c y") 'helm-yas-complete)
#+end_src

* Org mode

Load the almighty org-mode and do basic configuration:

- Set up global keybindings.
- Clear some local keybindings that gets in the way.
- Also switch on auto-fill-mode in order to make prose easier to write.
- Ensure tables and blocks are still in monospace.

#+begin_src emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :bind (("C-c a" . org-agenda)
         ("C-c l" . org-store-link)
         ("C-c c" . org-capture)
         ("C-c C-x C-j" . org-clock-goto)
         :map org-mode-map
         ("C-<tab>" . nil)
         ("M-h" . nil))
  :config
  (setq org-edit-src-content-indentation 0)
  (set-face-attribute 'org-block  nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
  (add-hook 'org-mode-hook #'auto-fill-mode 1))
#+end_src

Set up fast selection for tags. Lots of them! Lowercase characters are for
categories, uppercase for contexts, including people. I could perhaps switch to
digits for contexts if clashes become a problem..

#+begin_src emacs-lisp
(setq org-tag-alist '(("admin" . ?a)
                      ("emacs" . ?e)
                      ("integrators" . ?i)
                      ("mdg" . ?m)
                      ("org" . ?o)
                      ("read" . ?r)
                      (:newline)
                      ("@home" . ?H)
                      ("@office" . ?O)
                      ("@standup" . ?S)
                      ("@tlf" . ?T)))
#+end_src

  Maybe everything should always auto-save all the time..?

#+begin_src emacs-lisp
;(add-hook 'auto-save-hook 'org-save-all-org-buffers)
#+end_src

** Some basic settings.

   I keep most of the stuff in my stuff repository. For now fleeting notes are
   recorded in an Inbox, which is a relic from an older GTD structure.

#+begin_src emacs-lisp
(setq org-directory "~/Repository"
      org-default-notes-file "~/Repository/Inbox.org"
      org-agenda-restore-windows-after-quit t
      org-agenda-window-setup 'current-window
      org-log-done t)

(setq org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "WAITING(w@)"
                                    "PROJ(p)" "INACTIVE(i)" "SOMEDAY(s)"
                                    "|" "DONE(d)" "CANCELLED(c@)")))
#+end_src

Emacs Lisp is a popular source language, so give it  its own key. As both "e"
and "E" are taken, it will have to live under "m".

#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist
             '("m" . "src emacs-lisp"))
#+end_src

Exporting to Slack allows me to edit the message in e.g. an org-mode note.

#+begin_src emacs-lisp
(use-package ox-slack)
#+end_src

** Pomodoro

#+begin_src emacs-lisp
(use-package org-pomodoro)
#+end_src

** Contacts

It's easy to just stuff contacts into some random address book (GMail, your
phone, ...), but let's take a step back: Contacts are /people/ that you deal
with. Many of them you will deal with for years or decades. They should not just
be thrown into an address book as an afterthought.

#+begin_src emacs-lisp
(use-package org-contacts
   :ensure nil
   :after org
   :custom (org-contacts-files '("~/Repository/People/Contacts.org")))
#+end_src

** Bookmarks

#+begin_src emacs-lisp
(use-package org-cliplink
  :bind (:map org-mode-map
              ("C-c L" . org-cliplink)))
#+end_src

** Agenda setup

This is has been changing a lot, but the current idea is that I want to fetch
tasks from:

- Calendars, to show in the weekly agenda view.
- My projects repository, which is kind of legacy.
- Everything inside the interests and roles contexts.
   
#+begin_src emacs-lisp
(setq org-agenda-files
      (append
       '("~/.emacs.d/calendars"
         "~/Repository/Projects")
       (directory-files-recursively "~/Interests" "\.org$")
       (directory-files-recursively "~/Roles" "\.org$")))

(setq org-agenda-custom-commands
      '(("i" "Inbox"
         ((todo "TODO"
                ((org-agenda-files (list "~/Repository/Inbox.org"))))))
        ("n" "Next actions" todo "NEXT")
        ("p" "Projects" todo "PROJ")
        ("r" "Review"
         ((agenda)
          (stuck "")
          (tags-todo "@office")
          (tags-todo "@reading")
          (tags-todo "@home")
          (tags-todo "@project")))
        ("D" "Daily action list"
         ((agenda "" ((org-agenda-ndays 1)
                      (org-agenda-sorting-strategy
                       (quote ((agenda time-up priority-down tag-up) )))
                      (org-deadline-warning-days 0)))))))
#+end_src

** Capture and refile

Capture templates. NEXT is used for tasks I can start working on right away,
while TODO are effectively blocked. PROJ is for longer lived tasks with
sub-tasks. These are treated separately in weekly and daily reviews. MEETING is
used to record meetings, but I don't use it very often, so it's a candidate for
removal.

I use Diary to make a quick summary of the day, or when I have completed
significant tasks. Contacts is for recording new contacts, but it's mostly
experimental. Then there are templates for recurring meetings/standups that I
use for recording the outcome of these, and for tracking the time spent.

#+begin_src emacs-lisp
(setq org-capture-templates
      `(("n" "NEXT" entry (file+headline org-default-notes-file "Tasks")
         "* NEXT %i%?")
        ("t" "TODO" entry (file+headline org-default-notes-file "Tasks")
         "* TODO %i%?")
        ("p" "PROJ" entry (file+headline org-default-notes-file "Tasks")
         "* PROJ %i%?")
        ("m" "Meeting" entry (file+datetree "~/Contexts/WG2/Meetings.org")
         "* NEXT %? :meeting:\n%U" :clock-in t :clock-resume t)
        ("d" "Diary" entry (file+datetree "~/Repository/Timeline/Diary.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("c" "Contacts" entry (file ,(car (org-contacts-files)))
         "* %(org-contacts-template-name)
  :PROPERTIES:
  :EMAIL: %^{Email| }
  :PHONE: %^{Phone| }
  :END:\n** %u %?")
        ("s" "Standup" item
         (file+olp+datetree "~/Roles/TechLeadIntegrators.org" "Standups")
         "%?\n" :clock-in t :clock-resume t)
        ("l" "Tech lead sync" item
         (file+olp+datetree "~/Roles/TechLeadIntegrators.org" "Tech lead syncs")
         "%?\n" :clock-in t :clock-resume t)
        ("b" "Bookmark" entry (file "~/Bookmarks.org")
         "* %(org-cliplink-capture)\n%?" :empty-lines 1)))
#+end_src

I've dumbed down the refiling targets to just consider all the agenda files at
level one.

#+begin_src emacs-lisp
(setq org-refile-targets '((org-agenda-files :level . 1)))
#+end_src

** Roam

 Let's try to use the new Repository structure for org-roam. An alternative
 would have been to store it as a Context, but it's probably more of a cross
 context thing.

#+begin_src emacs-lisp
(setq org-roam-directory "~/Repository/Roam")
#+end_src

 Start org

#+begin_src emacs-lisp
(use-package org-roam
    :ensure t
    :bind (("C-c n f" . org-roam-find-file)
           :map org-roam-mode-map
           (("C-c n l" . org-roam)
            ("C-c n g" . org-roam-graph)
            ("C-c n t a" . org-roam-tag-add)
            ("C-c n t d" . org-roam-tag-delete))
           :map org-mode-map
           (("C-c n i" . org-roam-insert)
            ("C-c n I" . org-roam-insert-immediate)))
    :hook (after-init . org-roam-mode)
    :init
    (make-directory org-roam-directory t)
    :config
    (setq org-roam-completion-system 'helm))
 #+end_src

 Also set up org-journal with org-roam for fleeting notes, i.e. notes
 that are not connected to a particular project.

#+begin_src emacs-lisp
(use-package org-journal
  :bind
  ("C-c n j" . org-journal-new-entry)
  :init
  (setq org-journal-file-type 'weekly
        org-journal-dir org-roam-directory
        org-journal-date-prefix "* "
        org-journal-file-header "#+title: %Y journal, week %V\n"
        org-journal-file-format "%Y-%V.org"
        org-journal-date-format "%A, %d %B %Y"
        org-journal-carryover-items ""))
 #+end_src

* Version control

Bind magit to ~C-x g~, and unbind ~C-<tab>~ since it's used for switching
buffers.

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-x g" . magit)
         :map magit-mode-map
         ("C-<tab>" . nil)))
#+end_src
